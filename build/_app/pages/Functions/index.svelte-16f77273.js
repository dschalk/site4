import{S as Xe,i as Ze,s as $e,e as l,t as i,k as c,c as r,a as u,h as n,d as t,m as h,b as D,g as o,G as s,K as We}from"../../chunks/vendor-7ab9b2a4.js";function et(Ve){let f,se,C,d,ie,g,ne,le,G,k,re,j,b,ue,w,ce,z,S,he,O,I,fe,Y,T,de,L,_,me,q,x,pe,B,E,be,K,y,ye,H,ve,R,m,ge,P,ke,we,N,v,Se,Q,U,V,J,Ie,X,p,Te,M,_e,xe,Z,W,Ee,$,A,He,ee,F,Pe;return{c(){f=l("h2"),se=i("Introduction"),C=c(),d=l("p"),ie=i("This website is built on the SvelteKit framework. It's located on a Digital Ocean droplet. The "),g=l("a"),ne=i("async_with_Websockets"),le=i(" page is supported by two WebSockets servers on a separate Digital Ocean droplet."),G=c(),k=l("p"),re=i("Svelte modules look a lot like ordinary HTML pages, with JavaScript inside of script tags,  CSS in style tags, and, aside from just a few quirks, plain JavaScript. There's no virtual DOM. Svelte modules can be imported to facilitate reactivity and animation, among other things. Svelte is well documentat, with examples and interactive tutorials, so getting started and learning to use the modules effectively is easily."),j=c(),b=l("p"),ue=i("The modules in this presentation are small and isolated from other modules, making them easy to understand and maintain. There are no compelling reasons to avoid mutations and side effects, or to impose explicit type constraints on functions. There's no danger of introducing bugs, as would be the case in larger modules with more than one function reading or modifying global variables. Years ago, I elaborated on these ideas and presented examples at "),w=l("a"),ce=i("https://functional"),z=c(),S=l("p"),he=i("Functions that manipulate values other than those provided as arguments are dangerous where there are many lines of code. You might be scrupulously careful, but future maintainers might not understand your code as well as you do. If bugs appear, they might be difficult to trace."),O=c(),I=l("p"),fe=i('When the global space is just a small, isolated module, many established "best practices" can be safely ignored. Deviations from usually adhered-to best practices are tolerated inside of functions; why not in small, isolated modules?'),Y=c(),T=l("h3"),de=i("Ersatz Monads"),L=c(),_=l("p"),me=i(`"Monad" is rigorously defined in Category Theory, but not in this presentation. Here, a monad is a closure that returns a function that facilitates the composition of values (usualy functions) in ways that can be specified by the monad's definition. For example, the Promises Monad processes chains of values, mostly asynchronous functions, assigning results to various attributes of a global object that is synchronized with the DOM.`),q=c(),x=l("h3"),pe=i("Some Thoughts about Functional Programming"),B=c(),E=l("p"),be=i('"Functional programming is an approach to programming based on function calls as the primary programming construct." - Greg Michaelson on Page 3 of An Introduction to Functional Programming Through Lambda Calculus.'),K=c(),y=l("p"),ye=i(`I created this section of the schalk.net site to share my enthusiasm for JavaScript functions, and especially for the recursive closures I call "monads". This are what come to mind when I think of "functional programming." The prevalent concept of "functional programming" involves using only pure functions and immutable values. I enjoy coding in Haskell that way, but mindlessly wasting the power and flexibility of JavaScript in situations where nothing can be gained from it doesn't seem very bright. These situations include code affecting on the internal workings of functions, and small modules where clobbering values used by other functions is easily avoided and side effects have nowhere to hide when debugging and refactoring occur. When benchmarkers evaluate the efficiency of having lots of modules, they overlook this important factor. Years ago, I elaborated on some of this in `),H=l("a"),ve=i("https://functional.schalk.net/"),R=c(),m=l("p"),ge=i("I still have code for a fairly elaborate Haskell backend to an application I developed in 2013 and maintained for a while. It's a multi-player, multi-group simulated dice game based on a game my young son learned in school. It includes a shared group todo list and chat box. A version is online at "),P=l("a"),ke=i("https://score.schalk.net/"),we=i(" The drag & drop boxes are too big, the buttons could be better arranged, and the rules are missing. Maybe I'll spruce it up someday. The Haskell code and bare-bone rules are here:"),N=c(),v=l("a"),Se=i("Haskell Code"),Q=c(),U=l("br"),V=c(),J=l("p"),Ie=i('The rules of the Game of Score are missing right now. If you want to check out the multi-player simulated dice game, click Group A or Group B or make up a group name. Click "refresh" whenever it is available, then click "Roll". You get a point for making the number 20 in at least two computations.'),X=c(),p=l("p"),Te=i(`WebSockets traffic to and from the "schalk.site" Digitalocean droplet is encrypted. The "Game of Score" Haskell WebSockets server handles secure websockets traffic by reverse proxy to a background process running at http://127.0.0.1:3055. WebSockets packets addressed to wss://game.schalk.site get passed by the Nginx web server to http://127.0.0.1:3055 and responses to out addressed to wss://game.schalk.site. Here's a link to the front-end on the schalk.net droplet: `),M=l("a"),_e=i("https:/score.schalk.net"),xe=i("."),Z=c(),W=l("p"),Ee=i("It's such a joy, in the safety of small, isolated modules, to have the internal workings of a function rely on and mutate global variables - even variables that were not provided as arguments. When your functions don't have to be pure; for example, when you are free to define functions that return results only on every third, fourth, or whatever execution, JavaScript becomes more flexible and powerful. These sorts of things can be done safely in small, isolated modules."),$=c(),A=l("p"),He=i("Trying to make JavaScript functions behave like Haskell functions can be enriching and for some, much more entertaining than sudoku or crossword puzzles. Such endeavors, however, aren't likely to help us develop robust, easily maintainable applications."),ee=c(),F=l("p"),Pe=i('In the modules that follow, I define functions, experiment with functions, admire the power and possibilities of functions, and generally dwell on functions. If, to you, "functional JavaScript" means "cargo-cult JavaScript" (superstitiously imitating Haskell and similar languages), then call me a heretic. Still, I hope you will at least consider the possibility that in some circumstances, abandoning strict adherence to the so-called "functional paradigm" can greatly improve your JavaScript code.'),this.h()},l(e){f=r(e,"H2",{});var a=u(f);se=n(a,"Introduction"),a.forEach(t),C=h(e),d=r(e,"P",{});var te=u(d);ie=n(te,"This website is built on the SvelteKit framework. It's located on a Digital Ocean droplet. The "),g=r(te,"A",{href:!0});var Ae=u(g);ne=n(Ae,"async_with_Websockets"),Ae.forEach(t),le=n(te," page is supported by two WebSockets servers on a separate Digital Ocean droplet."),te.forEach(t),G=h(e),k=r(e,"P",{});var Fe=u(k);re=n(Fe,"Svelte modules look a lot like ordinary HTML pages, with JavaScript inside of script tags,  CSS in style tags, and, aside from just a few quirks, plain JavaScript. There's no virtual DOM. Svelte modules can be imported to facilitate reactivity and animation, among other things. Svelte is well documentat, with examples and interactive tutorials, so getting started and learning to use the modules effectively is easily."),Fe.forEach(t),j=h(e),b=r(e,"P",{});var Je=u(b);ue=n(Je,"The modules in this presentation are small and isolated from other modules, making them easy to understand and maintain. There are no compelling reasons to avoid mutations and side effects, or to impose explicit type constraints on functions. There's no danger of introducing bugs, as would be the case in larger modules with more than one function reading or modifying global variables. Years ago, I elaborated on these ideas and presented examples at "),w=r(Je,"A",{href:!0});var De=u(w);ce=n(De,"https://functional"),De.forEach(t),Je.forEach(t),z=h(e),S=r(e,"P",{});var Ce=u(S);he=n(Ce,"Functions that manipulate values other than those provided as arguments are dangerous where there are many lines of code. You might be scrupulously careful, but future maintainers might not understand your code as well as you do. If bugs appear, they might be difficult to trace."),Ce.forEach(t),O=h(e),I=r(e,"P",{});var Ge=u(I);fe=n(Ge,'When the global space is just a small, isolated module, many established "best practices" can be safely ignored. Deviations from usually adhered-to best practices are tolerated inside of functions; why not in small, isolated modules?'),Ge.forEach(t),Y=h(e),T=r(e,"H3",{});var je=u(T);de=n(je,"Ersatz Monads"),je.forEach(t),L=h(e),_=r(e,"P",{});var ze=u(_);me=n(ze,`"Monad" is rigorously defined in Category Theory, but not in this presentation. Here, a monad is a closure that returns a function that facilitates the composition of values (usualy functions) in ways that can be specified by the monad's definition. For example, the Promises Monad processes chains of values, mostly asynchronous functions, assigning results to various attributes of a global object that is synchronized with the DOM.`),ze.forEach(t),q=h(e),x=r(e,"H3",{});var Oe=u(x);pe=n(Oe,"Some Thoughts about Functional Programming"),Oe.forEach(t),B=h(e),E=r(e,"P",{});var Ye=u(E);be=n(Ye,'"Functional programming is an approach to programming based on function calls as the primary programming construct." - Greg Michaelson on Page 3 of An Introduction to Functional Programming Through Lambda Calculus.'),Ye.forEach(t),K=h(e),y=r(e,"P",{});var Me=u(y);ye=n(Me,`I created this section of the schalk.net site to share my enthusiasm for JavaScript functions, and especially for the recursive closures I call "monads". This are what come to mind when I think of "functional programming." The prevalent concept of "functional programming" involves using only pure functions and immutable values. I enjoy coding in Haskell that way, but mindlessly wasting the power and flexibility of JavaScript in situations where nothing can be gained from it doesn't seem very bright. These situations include code affecting on the internal workings of functions, and small modules where clobbering values used by other functions is easily avoided and side effects have nowhere to hide when debugging and refactoring occur. When benchmarkers evaluate the efficiency of having lots of modules, they overlook this important factor. Years ago, I elaborated on some of this in `),H=r(Me,"A",{href:!0});var Le=u(H);ve=n(Le,"https://functional.schalk.net/"),Le.forEach(t),Me.forEach(t),R=h(e),m=r(e,"P",{});var ae=u(m);ge=n(ae,"I still have code for a fairly elaborate Haskell backend to an application I developed in 2013 and maintained for a while. It's a multi-player, multi-group simulated dice game based on a game my young son learned in school. It includes a shared group todo list and chat box. A version is online at "),P=r(ae,"A",{href:!0});var qe=u(P);ke=n(qe,"https://score.schalk.net/"),qe.forEach(t),we=n(ae," The drag & drop boxes are too big, the buttons could be better arranged, and the rules are missing. Maybe I'll spruce it up someday. The Haskell code and bare-bone rules are here:"),ae.forEach(t),N=h(e),v=r(e,"A",{href:!0});var Be=u(v);Se=n(Be,"Haskell Code"),Be.forEach(t),Q=h(e),U=r(e,"BR",{}),V=h(e),J=r(e,"P",{});var Ke=u(J);Ie=n(Ke,'The rules of the Game of Score are missing right now. If you want to check out the multi-player simulated dice game, click Group A or Group B or make up a group name. Click "refresh" whenever it is available, then click "Roll". You get a point for making the number 20 in at least two computations.'),Ke.forEach(t),X=h(e),p=r(e,"P",{});var oe=u(p);Te=n(oe,`WebSockets traffic to and from the "schalk.site" Digitalocean droplet is encrypted. The "Game of Score" Haskell WebSockets server handles secure websockets traffic by reverse proxy to a background process running at http://127.0.0.1:3055. WebSockets packets addressed to wss://game.schalk.site get passed by the Nginx web server to http://127.0.0.1:3055 and responses to out addressed to wss://game.schalk.site. Here's a link to the front-end on the schalk.net droplet: `),M=r(oe,"A",{href:!0});var Re=u(M);_e=n(Re,"https:/score.schalk.net"),Re.forEach(t),xe=n(oe,"."),oe.forEach(t),Z=h(e),W=r(e,"P",{});var Ne=u(W);Ee=n(Ne,"It's such a joy, in the safety of small, isolated modules, to have the internal workings of a function rely on and mutate global variables - even variables that were not provided as arguments. When your functions don't have to be pure; for example, when you are free to define functions that return results only on every third, fourth, or whatever execution, JavaScript becomes more flexible and powerful. These sorts of things can be done safely in small, isolated modules."),Ne.forEach(t),$=h(e),A=r(e,"P",{});var Qe=u(A);He=n(Qe,"Trying to make JavaScript functions behave like Haskell functions can be enriching and for some, much more entertaining than sudoku or crossword puzzles. Such endeavors, however, aren't likely to help us develop robust, easily maintainable applications."),Qe.forEach(t),ee=h(e),F=r(e,"P",{});var Ue=u(F);Pe=n(Ue,'In the modules that follow, I define functions, experiment with functions, admire the power and possibilities of functions, and generally dwell on functions. If, to you, "functional JavaScript" means "cargo-cult JavaScript" (superstitiously imitating Haskell and similar languages), then call me a heretic. Still, I hope you will at least consider the possibility that in some circumstances, abandoning strict adherence to the so-called "functional paradigm" can greatly improve your JavaScript code.'),Ue.forEach(t),this.h()},h(){D(g,"href","Functions/Monads/Async_monad"),D(w,"href","https://functional.schalk.net"),D(H,"href","https://functional.schalk.net"),D(P,"href","score.schalk.net"),D(v,"href","../Functions/score"),D(M,"href","https://score.schalk.net")},m(e,a){o(e,f,a),s(f,se),o(e,C,a),o(e,d,a),s(d,ie),s(d,g),s(g,ne),s(d,le),o(e,G,a),o(e,k,a),s(k,re),o(e,j,a),o(e,b,a),s(b,ue),s(b,w),s(w,ce),o(e,z,a),o(e,S,a),s(S,he),o(e,O,a),o(e,I,a),s(I,fe),o(e,Y,a),o(e,T,a),s(T,de),o(e,L,a),o(e,_,a),s(_,me),o(e,q,a),o(e,x,a),s(x,pe),o(e,B,a),o(e,E,a),s(E,be),o(e,K,a),o(e,y,a),s(y,ye),s(y,H),s(H,ve),o(e,R,a),o(e,m,a),s(m,ge),s(m,P),s(P,ke),s(m,we),o(e,N,a),o(e,v,a),s(v,Se),o(e,Q,a),o(e,U,a),o(e,V,a),o(e,J,a),s(J,Ie),o(e,X,a),o(e,p,a),s(p,Te),s(p,M),s(M,_e),s(p,xe),o(e,Z,a),o(e,W,a),s(W,Ee),o(e,$,a),o(e,A,a),s(A,He),o(e,ee,a),o(e,F,a),s(F,Pe)},p:We,i:We,o:We,d(e){e&&t(f),e&&t(C),e&&t(d),e&&t(G),e&&t(k),e&&t(j),e&&t(b),e&&t(z),e&&t(S),e&&t(O),e&&t(I),e&&t(Y),e&&t(T),e&&t(L),e&&t(_),e&&t(q),e&&t(x),e&&t(B),e&&t(E),e&&t(K),e&&t(y),e&&t(R),e&&t(m),e&&t(N),e&&t(v),e&&t(Q),e&&t(U),e&&t(V),e&&t(J),e&&t(X),e&&t(p),e&&t(Z),e&&t(W),e&&t($),e&&t(A),e&&t(ee),e&&t(F)}}}class at extends Xe{constructor(f){super();Ze(this,f,null,et,$e,{})}}export{at as default};
