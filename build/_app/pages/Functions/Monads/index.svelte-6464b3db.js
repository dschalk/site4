import{S as z,i as K,s as q,k,e as h,t as u,m as E,c,a as b,h as S,d as a,b as U,f as P,g as s,G as d,K as F,q as Q,o as W,M as j,N as V,O as B}from"../../../chunks/vendor-7ab9b2a4.js";function X(L){let t,y,p,m,g,o,n;return{c(){t=h("div"),y=h("p"),p=u(`
SEQUENCING, ISOLATING, AND PRESERVING OPERATIONS ON DATA
`),m=h("br"),g=u(` 
 USING JAVASCRIPT CLOSURES AND HASKELL MONADS`),this.h()},l(r){t=c(r,"DIV",{style:!0});var l=b(t);y=c(l,"P",{}),b(y).forEach(a),p=S(l,`
SEQUENCING, ISOLATING, AND PRESERVING OPERATIONS ON DATA
`),m=c(l,"BR",{}),g=S(l,` 
 USING JAVASCRIPT CLOSURES AND HASKELL MONADS`),l.forEach(a),this.h()},h(){P(t,"font-family","Times New Roman"),P(t,"text-align","center"),P(t,"font-size","32px")},m(r,l){s(r,t,l),d(t,y),d(t,p),d(t,m),d(t,g),n=!0},i(r){n||(j(()=>{o||(o=V(t,B,{},!0)),o.run(1)}),n=!0)},o(r){o||(o=V(t,B,{},!1)),o.run(0),n=!1},d(r){r&&a(t),r&&o&&o.end()}}}function Y(L){let t,y,p,m,g,o,n,r,l,A,w,I,_,C,T,v,G,N,O,H,f=X();return{c(){f&&f.c(),t=k(),y=h("br"),p=k(),m=h("span"),g=u(`Monad (from Greek \u03BC\u03BF\u03BD\u03AC\u03C2 monas, "singularity" in turn from \u03BC\u03CC\u03BD\u03BF\u03C2 monos, "alone")[1] refers, in cosmogony, to the Supreme Being, divinity or the totality of all things. A basic unit of perceptual reality is a "monad" in Gottfried Leibniz'`),o=k(),n=h("span"),r=u("Monadology"),l=k(),A=h("span"),w=u(", published in 1714. A single note in music theory is called a monad."),I=k(),_=h("p"),C=u(`Monads in the Haskell Programming Language were inspired by Category Theory monads. The Haskell programming language isn't a mathematical category and its monads certainly aren't Category-Theory monads. The closures mentioned in the title (above) were inspired by Haskell monads. From now on, I'll call the JavaScript closures "monads" and remind scoffers that Haskell monads are not Category Theory monads either, contrary to what they may have been told. With some finageling, Haskell types and isomorphisms among them can be made into a Category. It's called "Hask."`),T=k(),v=h("p"),G=u("My Github respository shows some of the variations on the theme of JavaScript monads I experimented with over the years. Proving they obey the monad rules, stated in Haskell documentation but optional in practice, was interesting and reassuring. "),N=h("a"),O=u("dschalk repository"),this.h()},l(e){f&&f.l(e),t=E(e),y=c(e,"BR",{}),p=E(e),m=c(e,"SPAN",{class:!0});var i=b(m);g=S(i,`Monad (from Greek \u03BC\u03BF\u03BD\u03AC\u03C2 monas, "singularity" in turn from \u03BC\u03CC\u03BD\u03BF\u03C2 monos, "alone")[1] refers, in cosmogony, to the Supreme Being, divinity or the totality of all things. A basic unit of perceptual reality is a "monad" in Gottfried Leibniz'`),i.forEach(a),o=E(e),n=c(e,"SPAN",{style:!0});var M=b(n);r=S(M,"Monadology"),M.forEach(a),l=E(e),A=c(e,"SPAN",{});var x=b(A);w=S(x,", published in 1714. A single note in music theory is called a monad."),x.forEach(a),I=E(e),_=c(e,"P",{});var D=b(_);C=S(D,`Monads in the Haskell Programming Language were inspired by Category Theory monads. The Haskell programming language isn't a mathematical category and its monads certainly aren't Category-Theory monads. The closures mentioned in the title (above) were inspired by Haskell monads. From now on, I'll call the JavaScript closures "monads" and remind scoffers that Haskell monads are not Category Theory monads either, contrary to what they may have been told. With some finageling, Haskell types and isomorphisms among them can be made into a Category. It's called "Hask."`),D.forEach(a),T=E(e),v=c(e,"P",{});var R=b(v);G=S(R,"My Github respository shows some of the variations on the theme of JavaScript monads I experimented with over the years. Proving they obey the monad rules, stated in Haskell documentation but optional in practice, was interesting and reassuring. "),N=c(R,"A",{href:!0});var J=b(N);O=S(J,"dschalk repository"),J.forEach(a),R.forEach(a),this.h()},h(){U(m,"class","tao"),P(n,"font-style","italic"),U(N,"href","https://github.com/dschalk?tab=repositories")},m(e,i){f&&f.m(e,i),s(e,t,i),s(e,y,i),s(e,p,i),s(e,m,i),d(m,g),s(e,o,i),s(e,n,i),d(n,r),s(e,l,i),s(e,A,i),d(A,w),s(e,I,i),s(e,_,i),d(_,C),s(e,T,i),s(e,v,i),d(v,G),d(v,N),d(N,O),H=!0},p:F,i(e){H||(Q(f),H=!0)},o(e){W(f),H=!1},d(e){f&&f.d(e),e&&a(t),e&&a(y),e&&a(p),e&&a(m),e&&a(o),e&&a(n),e&&a(l),e&&a(A),e&&a(I),e&&a(_),e&&a(T),e&&a(v)}}}class $ extends z{constructor(t){super();K(this,t,null,Y,q,{})}}export{$ as default};
